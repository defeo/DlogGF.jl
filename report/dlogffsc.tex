\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb,amsthm,amsopn}
\usepackage{mathrsfs}
\usepackage{graphicx}
%\usepackage{tikz}
%\usepackage{array}
%\usepackage[top=1cm,bottom=1cm]{geometry}
%\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=red,
}

\newtheoremstyle{break}%
{}{}%
{\itshape}{}%
{\bfseries}{}%  % Note that final punctuation is omitted.
{\newline}{}

\newtheoremstyle{sc}%
{}{}%
{}{}%
{\scshape}{}%  % Note that final punctuation is omitted.
{\newline}{}

\theoremstyle{break}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lm}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}

\theoremstyle{sc}
\newtheorem{exo}{Exercise}

\theoremstyle{definition}
\newtheorem{defi}[thm]{Definition}
\newtheorem{ex}[thm]{Example}

\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}

\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\Img}{Im}
\DeclareMathOperator{\Card}{Card}
\DeclareMathOperator{\Vect}{Vect}
\DeclareMathOperator{\Tr}{Tr}


% Nouvelles commandes
\newcommand{\ps}[2]{\left\langle#1,#2\right\rangle}
\newcommand{\ent}[2]{[\![#1,#2]\!]}
\newcommand{\diff}{\mathop{}\!\mathrm{d}}
\newcommand{\ie}{\emph{i.e. }}
% know what is going on or when I still need to ckeck

% opening
\title{Internship report\\\textbf{Discrete logarithm in finite fields of
small characteristic}}
\author{Édouard \textsc{Rousseau}\\\textit{Supervised by}\\Éric \textsc{Schost} and Luca
\textsc{De Feo}}

\begin{document}

\maketitle

\begin{abstract}
This internship took place from March to September 2017 in the Symbolic
Computation Group of the University of Waterloo. We studied the recent
breakthroughs in the discrete logarithm world, in the finite field of small characteristic case.
As part of this study, we implemented the encountered algorithms and made them
available as an open-source library written in Julia/Nemo~\cite{Julia, Nemo}.
\end{abstract}

\tableofcontents

\clearpage

\section{Introduction}

With the rise of new technologies and new communication media, the importance of
cryptography has been widely growing up. In 1976, a new era of cryptography was
born, with the invention of \emph{public-key} cryptography by Diffie and
Hellman, in their article ``New Directions in Cryptography''~\cite{DH76}. Today,
cryptography is omnipresent, though mostly invisible to the user. Even if
millions of public-key protocols are executed each second, there are only two
main candidates to design those protocols. In other words, those protocols are
very often based either on integer factorization (like the well known
and intensively used RSA protocol), or on discrete logarithm. The Discrete
Logarithm Problem (DLP) is fairly easy to state. Let $\mathcal G=\left\langle
g\right\rangle$ be a cyclic group generated by an element
$g$, and denote by $N=|\mathcal G|$ its cardinal. We have the isomorphism:
\[
 \begin{array}{cccc}
   exp_g: & \mathbb{Z}/N\mathbb{Z} & \to & \mathcal G \\
   & n & \mapsto & g^n,
 \end{array}
\]
and we denote by $\log_g=\exp_g^{-1}$ the inverse isomorphism (sometimes only
denoted by $\log$). In practice, the
\emph{square and multiply} algorithm allows us to compute $g^n=\exp_g(n)$
efficiently, \ie in polynomial time. But, given $y = g^k$, the computation of $k
= \log_g(y)$ is not as easy. This kind of function $f$, where $f$ is easy to
compute but $f^{-1}$ is hard to compute, is called \emph{one-way} function.
It is
typically used in cryptology to make the encryption fast and the deciphering
slow. 

In fact, discrete
logarithms were studied long before their utilization in cryptography. Indeed,
Gauß, in its \emph{Disquisitiones Arithmeticae}, back in 1801, was already
computing discrete logarithms, that he reffered to as \emph{indices}.
Nevertheless, the discrete logarithm really became a practical relevant problem
with the invention of the Diffie-Hellman key exchange protocol~\cite{DH76}. The
security of the protocol originally relied on the hardness of the discrete
logarithm problem in $(\mathbb{Z}/N\mathbb{Z})^\times$. This group is no longer
secure, but other interesting groups can be used, such as the points of an
elliptic curve or the multiplicative group of a finite field. In this
internship, we focused on that last case. Over the years, two
types of algorithms emerged:
\begin{itemize}
  \item the \emph{generic} algorithms, that can be used for any group, with an
    exponential complexity of type $O(\sqrt N)$, where $N=|\mathcal G|$ is the cardinal
    of the group;
  \item the \emph{index calculus} algorithms, that are built on the structure of
    the group considered, and that have very different complexities, depending
    on the kind of the studied group.
\end{itemize}

To express the complexity of an algorithm, one usually uses the notation
\[
  L_N(\alpha, c) = \exp((c+o(1))(\log N)^\alpha(\log\log N)^{1-\alpha})
\]
where $\alpha\in[0, 1]$, $c>0$, and $\log$ denotes the natural logarithm. We may
omit the subscript $N$ if there is no ambiguity, or even denote
$L(\alpha)$ to indicate $L(\alpha, c)$ for some constant $c>0$, if we do not
want to precise the constant. This notation can be seen as an interpolation
between the polynomial complexity $L(0)=(\log N)^{c+o(1)}$ and the exponential
complexity $L(1)=N^{c+o(1)}$. An algorithm with complexity $L(\alpha)$, for
$0<\alpha<1$, is said to have a \emph{sub-exponential} complexity.

When Diffie and Hellman wrote their article in 1976, the known algorithms
had exponential complexities. The first sub-exponential algorithm for the
discrete logarithm in finite field was analysed
in 1979 by Adleman~\cite{Adleman79}, it had complexity $L(1/2)$. In 1984, 
Coppersmith designed
an algorithm to handle the case of binary fields~\cite{Coppersmith84} with 
complexity $L(1/3)$. Other
algorithms were invented, generalized, or improved, among them the FFS
(Function Field Sieve) and NFS (Number Field Sieve), so that in 2006, every type
of finite field was covered with complexity $L(1/3)$. This complexity remains
the best in medium and large characteristic. In the small
characteristic case, however, there had been a serie of dramatic
improvements that let us with \emph{quasi-polynomial} algorithms. If we denote
by $l$ the bitlength of the finite field in which we work, a quasi-polynomial
complexity is of the form
\[
  l^{O(\log l)}.
\]
This complexity is smaller than $L(\varepsilon)$ for any
$\varepsilon>0$, but larger than the polynomial complexity $L(0)$, so it
is sometimes denoted as $L(o(1))$.

The recent algorithms that achieve quasi-polynomial complexity are index
calculus algorithms, so we introduce this method in
Section~\ref{index-calculus}. We study the first quasi-polynomial algorithm, due to
Barbulescu, Gaudry, Joux and Thomé in Section~\ref{bgjt}. In particular we show
how to compute the logarithms of the factor base in this section. We study the
second quasi-polynomial algorithm, due to Granger, Kleinjung and Zumbrägel,
which is more efficient in practice, in Section~\ref{powers-of-2}.

\section{The index calculus method}
\label{index-calculus}

Here again, we consider a group $\mathcal G=\left\langle g \right\rangle$, an element
$g^k = y\in \mathcal G$, and we want to compute $k$. The index calculus algorithms always
follow the same pattern:
\begin{enumerate}
  \item[0.] we choose $\mathcal F\subset \mathcal G$ such that $\left\langle
    \mathcal F \right\rangle = \mathcal G$
    (we often have $g\in \mathcal F$), this subset is called the \emph{factor base};
  \item we generate multiplicative relations between the elements of $\mathcal F$, \ie we
    find $f_1, \dots, f_n \in \mathcal F$ and $e_1, \dots, e_n\in \mathbb{Z}$ such that
    $\prod_i f_i^{e_i} = 1$, that is equivalent to the linear equation $\sum_i
    e_i\log_g(f_i) = 0$;
  \item we solve the linear system with unknowns $\log_g(f_i)$ arising from step
    1 to obtain $\log(f)$ for all $f\in \mathcal F$;
  \item we find a multiplicative relation between $y$ and elements of $\mathcal F$, or
    equivalently, we express $\log_g y = k$ as a linear combination of the
  $\log_g(f_i)$.
\end{enumerate}
As a first example, we introduce Adleman's algorithm. We let $\mathcal
G=\mathbb{F}_p^\times$ be the multiplicative group of a prime field
$\mathbb{F}_p=\mathbb{Z}/p\mathbb{Z}$, and we let our factor base be 
\[
  \mathcal F =\left\{ f\;|\;f\leq B, f\text{ prime} \right\}
\]
where $B\in \mathbb{N}$ is an integer that has yet to be determined, and where
we make the abuse of notation of denoting by $f$ both the integer
$f\in\mathbb{N}$ and its class $\bar f\in\mathbb{F}_p$. We assume that
$g\in\mathcal F$, otherwise we add $g$ to $\mathcal F$. In order to generate
multiplicative relations, we take a random $e\in\mathbb{Z}/(p-1)\mathbb{Z}$ and
we compute $g^e$, we say that $e$ yields a relation if the lift
$g^e\in\mathbb{N}$ is $B$-smooth, \ie if $g^e$ has only prime divisors $\leq B$.
In that case we have a relation 
\[ 
  g^e \equiv \prod_{f\in \mathcal F}f^{e_f} \mod p
\]
in the integers, that becomes 
\[ 
  g^e = \prod_{f\in \mathcal F}f^{e_f}
\]
in $\mathbb{F}_p$ (with the same abuse of notation), and where the exponents are
just some integers $e_f\in\mathbb{N}$. In terms of the logarithms, we write this
relation
\[
  e = \sum_{f\in\mathcal F} e_f\log f.
\]
Once we have enough relations, meaning more than $|\mathcal F|$, we are able to
recover the unknowns $\log f$ using classic linear algebra algorithms. Note that
the system is usually sparse, since the relations hardly contain all the
elements $f\in\mathcal F$. If the target element is some $h\in\mathcal G$, we
proceed in the same way to recover $\log h$. We take some
$e\in\mathbb{Z}/(p-1)\mathbb{Z}$ at random and compute $hg^e$. Once again, if
the lift of $hg^e$ is $B$-smooth, you have an equation of type
\[
  \log h + e = \sum_{f\in\mathcal F}h_f\log f
\]
where the $h_f\in\mathbb{N}$ are integers and all the $\log f$ are now known, so
we are able to recover the logarithm of $h$. The larger $B$ is, the easier it is
to obtain multiplicative relations. But at the same time, the size of $\mathcal
F$ will also become larger and we will need more multiplicative relations to
compute all the unknowns $\log f$. Adleman~\cite{Adleman79} showed that with a suitable choice of
$B$, this algorithms has a $L(1/2)$ complexity.

Even if the pattern is almost identical in every index calculus algorithm, there
are a lot of available strategies to generate multiplicative relations and
express the target element as a combination of elements in the factor base. This
led to a a rich variety of algorithms, among them is the BGJT algorithm, that is
studied in next section.

\section{The BGJT algorithm}
\label{bgjt}

The BGJT algorithm gets its name from its author: Barbulescu, Gaudry, Joux and
Thomé. It was first published in 2013~\cite{BGJT13} and it is the first
(heuristic) quasi-polynomial algorithm. The main ideas were already present in a
previous work of Joux~\cite{Joux13}, published earlier in 2013 and leading to
an algorithm with complexity $L(1/4 + o(1))$. Before giving those ideas, we
recall the general setup in which we perform the algorithm.

\subsection{Setup of the algorithms}

Let $\mathcal G = (\mathbb{F}_{q^n})^\times$ the multiplicative group of a finite
field of small characteristic $\mathbb{F}_{q^n}$, where $q=p^l$ is a prime
power. Here, and the same will be true for Section~\ref{powers-of-2}, by
\emph{small characteristic} we mean that $q$ must be a polynomial in the size of
the field $q^n$, \ie $q = L_{q^n}(0)$. In other documents, the term ``small
characteristic'' may indicates that $q = L_{q^n}(\alpha)$ for
$\alpha<\frac{1}{3}$. Assuming $q=L_{q^n}(\alpha)$ for a value
$\alpha<\frac{1}{3}$ in the BGJT algorithm would result in complexity
$L_{q^n}(\alpha+o(1))$, so it would no longer be quasi-polynomial, and that is
why we make the assumption that $q$ is polynomial in $q^n$. Note that even if
less impressive than quasi-polynomial complexity, $L_{q^n}(\alpha+o(1))$ is
still better than previously known algorithms for a large sample of finite
fields. We also assume that there is a ``medium subfield'' in
$\mathbb{F}_{q^n}$, \ie a field of size $\mathbb{F}_{q^2}$. In other words, we
ask that $n = 2m$ for some $m>0$. If this is not the case, we first embed our
field $F_{q^n}$ in a larger field. In this context, we represent elements of
$\mathbb{F}_{q^n}$ by polynomials over $\mathbb{F}_{q^2}$ of degree less than
$m$. Our factor base $\mathcal F\subset\mathcal G$ will be the set of elements
represented by degree one polynomials. We have not made precise what polynomial
$P$ we use to represent
$\mathbb{F}_{q^n}=\mathbb{F}_{q^{2m}}\cong\mathbb{F}_{q^2}[X]/(P)$, but it is done
in Section~\ref{ideas}. Again, we will make a notation abuse and if we have
$Q\in \mathbb{F}_{q^2}[X]$, we will still note $Q$ for the class $\bar Q\in
\mathbb{F}_{q^2}[X]/(P)$. Conversely, if we have an element $Q\in
\mathbb{F}_{q^{2m}}$, we
will also denote by $Q$ the polynomial in $\mathbb{F}_{q^2}[X]$ representing the
element.

\subsection{Background ideas}
\label{ideas}

In the case of $\mathbb{Z}/p\mathbb{Z}$, we used the decomposition of the
integers into prime factors to generate multiplicative relations. The situation
here is analogue: we decompose some polynomials into irreducible polynomials of
lower degree to get relations. Before going into details, we list three ideas
(first stated in~\cite{Joux13}) used in the algorithm.

\paragraph{Idea 1: homographies.} Given a polynomial $Q$ that factors nicely
(and thus is susceptible to give nice relations), we can product a lot of other
polynomials using change of variables induced by homographies:
\[
  X\to\frac{aX+b}{cX+d}.
\]
We see that $Q(\frac{aX+b}{cX+d})$ is not a polynomial, so by change of variable
using homographies, we mean homogeneous evaluation at $\frac{aX+b}{cX+d}$,
meaning the polynomial:
\[
  Q_{abcd}(X) = (cX+d)^{\deg Q}Q\left(\frac{aX+b}{cX+d} \right).
\]
If we have the decomposition $Q=\gamma\prod_j Q_j$, with $\gamma$ a constant and
$Q_j$ irreducible and monic polynomials, then we also have
\[
  Q_{abcd}(X) = \gamma\prod_j (cX+d)^{\deg Q_j}Q_j(\frac{aX+b}{cX+d})
\]
but the new factors in this decomposition are not necessary irreducible, not
necessary monic and may even have a lower degree than the original $Q_j$.

\paragraph{Idea 2: systematic polynomial splitting.} The second idea is to use
the polynomial $X^q-X$ because we already know that it factors into linear
polynomial over $\mathbb{F}_q$. Thus, instead of looking for a random candidate to
apply the first idea, we always use $X^q-X$.

\paragraph{Idea 3: defining polynomial.} We want to take advantage of the liberty that we
have for the irreducible polynomial $P$ defining
$\mathbb{F}_{q^{2m}}=\mathbb{F}_{q^2}[X]/(P)$.


\section{The powers-of-2 algorithm}
\label{powers-of-2}
\subsection{Setup of the algorithm}

Let $\mathcal G = (\mathbb{F}_{q^n})^\times$ the multiplicative group of a finite
field of small characteristic $\mathbb{F}_{q^n}$, where $q=p^l$ is a prime
power, and we represent elements of $\mathbb{F}_{q^n}$ by polynomials over
$\mathbb{F}_q$ of degree less than $n$. The setup in which we present the algorithm is slightly different from
the original, thanks to the work of Joux and Pierrot in \cite{JP14}. Indeed,
they remarked that working with polynomials of degree up to $d$ over $\mathbb{F}_q$ is
essentially equivalent as working with linear polynomials over $\mathbb{F}_{q^d}$. Thus,
instead of working with a factor base composed of linear polynomials over
$\mathbb{F}_{q^d}$ (with $d$ usually between $2$ and $4$), we work with a
factor base composed of irreducible polynomials up to degree $4$. Joux and Pierrot
precisely give a way to compute such a factor base in~\cite{JP14}, that is based
on previous work~\cite{Joux13, BGJT13} and has a complexity of $O(q^6)$. Since
we work in the case where $q$ is polynomial in the bitsize of the field
$\log(q^n)$, this precomputation time is polynomial.

Let us come back to the elements of $\mathbb{F}_{q^n}$, we said that they were
represented by polymomials of degree at most $n-1$ over $\mathbb{F}_q$. More
precisely, we consider $\mathbb{F}_{q^n}\cong \mathbb{F}_{q}[X]/(P)$ where $P\in
\mathbb{F}_{q}[X]$ is an irreducible polynomial of degree $n$ over
$\mathbb{F}_{q}$ dividing $h_1X^q-h_0$, and $h_0, h_1\in \mathbb{F}_q[X]$ are
polynomials of degree at most $2$ over $\mathbb{F}_q$. Different options are
available to choose $h_0$ and $h_1$, and the respective results are also
discussed in~\cite{JP14}. The existence of such parameters $h_0$ and $h_1$ is
critical for the algorithm, and the fact that every finite field admits such a
structure is \emph{heuristic}, and remains one of the major open problems in the
area.

We now assume that the factor base $\mathcal F$ is composed of all the
elements of $\mathcal G$ represented by an irreducible polynomial of degree at
most $4$. We also suppose that we know the logarithm of each element in
$\mathcal F$. In other words, we assume that the steps $1$ and $2$ of the index
calculus method have already been performed. The only remaining step is $3$,
where we express the logarithm of an element in $\mathcal G$ as the linear
combination of the logarithms of elements in $\mathcal F$. In order to perform
that step, we express the logarithm of the element that we want to study, denoted by
$Q\in\mathcal G$, as a linear combination of ``simpler'' $q+2$ elements $Q_j$,
\ie elements represented by polynomials of degree two times smaller. We
still note $Q$ for the polynomial representing $Q\in
\mathcal G$, and so we have $\deg Q_i\leq \lceil \frac{1}{2}\deg Q\rceil$. Doing
the same process reccursively, we are able to express $\log Q$ as a linear
combination of elements of degree at most $4$, \ie elements in $\mathcal F$.
This whole procedure is called the \emph{descent}, and we explain it in the
following. 

\subsection{On-the-fly degree $2$ elimination}

The crucial part of the descent is called the \emph{on-the-fly}
elimination. It allows one to express a degree $2$ polynomial
$Q\in\mathbb{F}_{q^m}[X]$ over $\mathbb{F}_{q^m}$ as a product of degree $1$ 
polynomials over $\mathbb{F}_{q^m}$. The name ``on the fly'' is due to the fact
that no relation gathering or linear algebra is performed during this
elimination. At the core of this elimination we also use the fact that the
polynomial $\mathcal P_B = X^{q+1}-BX+B$ splits completely over $\mathbb{F}_{q^m}$ (\ie is a
product of polynomial of degree $1$ over $\mathbb{F}_{q^m}$) very often. Let
$\mathcal B$ be the set of elements $B\in \mathbb{F}_{q^m}$ such that $\mathcal
P_B$ splits completely. In~\cite{Bluher04}, the roots and the splitting field of
$\mathcal P_B$ are studied and it is shown that the cardinality of $\mathcal B$
is approximately $q^{m-3}$ ($(q^{m-1}-1)/(q^2-1)$ when $m$ is odd,
$(q^{m-1}-q)/(q^2-1)$ when $m$ is even). Thus, if $B\in \mathcal B$,
$a,b,c\in\mathbb{F}_{q^m}$ such that $c\neq ab$, $a^q\neq b,
B=\frac{(b-a^q)^{q+1}}{(c-ab)^q}$, we see by the change of variable
$X\to\frac{ab-c}{b-a^q}X-a$ in $X^{q+1}+aX^q+bX+c$ that this polynomial
splits completely whenever $\mathcal P_B$ does. To see that, let us consider the
change of variable $X\mapsto uX+v$ in $X^{q+1}+aX^q+bX+c$, where $u$ and $v$ are
to be determined. We obtain the new polynomial
\[
  u^{q+1}X^{q+1}+(u^qv+au^q)X^q+(uv^q+bu)X+v^{q+1}+av^q+bv+c.
\]
If we want this polynomial to be of the form $\mathcal P_B$, we must impose that
\[
\begin{cases}
  u^qv+au^q = 0 \\
  uv^q+bu+v^{q+1}+av^q+bv+c = 0
\end{cases}.
\]
We know that $u\neq0$, otherwise the change of variable is trivial, so we deduce
that $v=-a$. Then, we note that $v^{q+1}+av^q=((-1)^{q+1}+(-1)^q)a^{q+1}=0$. So
the second equation becomes $u(-1)^qa^q+bu-ba+c = 0$, and we deduce that
$u=\frac{ab-c}{b+(-1)^qa^q}$. Assuming that we work with odd characteristic
(otherwise the formula can be adapted), we obtain the annonced change of
variable. Dividing by the leading coefficient $u^{q+1}$, we also have the
equality $B = \frac{(b-a^q)^{q+1}}{(c-ab)^q}$.
Note that using~\cite{Bluher04,
HK10, GKZ14}, we also know that $\mathcal B$ is the image of
$\mathbb{F}_{q^m}\setminus\mathbb{F}_{q^2}$ under the map 
\[
  u\mapsto \frac{(u-u^{q^2})^{q+1}}{(u-u^q)^{q^2+1}}\footnote{There is a proof
  in \cite{GKZ16b} but it is quite mysterious to me.}.
\]

In order to eliminate the polynomial $Q$, we define the lattice $L_Q\subset
\mathbb{F}_{q^m}[X]^2$ by 
\[
  L_Q = \left\{ (w_0,
    w_1)\in\mathbb{F}_{q^m}[X]^2\;|\;w_0h_0+w_1h_1\equiv0\;\mod Q \right\}.
\]
If $Q$ divides $w_0h_0+w_1h_1\neq0$ for $w_0, w_1\in \mathbb{F}_{q^m}$, then we have
$Q = w(w_0h_0+w_1h_1)$ for some $w\in\mathbb{F}_{q^m}^\times$ because the degree
of the right hand side is at most $2$. Hence, the logarithm of $Q$ is linked
with the logarithm of $w_0X^q+w_1=(w_0^{q^{m-1}}X+w_1^{q^{m-1}})^q$, and so the
logarithm of $Q$ is linked to the logarithm of a linear
polynomial over $\mathbb{F}_{q^m}$. Otherwise we can find a basis of $L_Q$
of the form $(u_0, X+u_1), (X+v_0, v_1)$ with $u_i, v_i\in\mathbb{F}_{q^m}$
using linear algebra. To do that, we denote $Q = X^2 + dX+ e$ (it does not
change the results to suppose that $Q$ is monic), $\bar h_0 = h_0 \mod Q =
d_0X+e_0$, $\bar h_1 = h_1 \mod Q = d_1X+e_1$, and $(w_0, w_1)$ a solution, with
$w_0=\alpha_0X+\beta_0$ and $w_1=\alpha_1X+\beta_1$. We seek a basis of the form
$(u_0, X + u_1), (X+v_0, v_1)$, that is to say that the solutions $(w_0, w_1)$
can be written $\lambda(u_0, X+u_1)+\mu(X+v_0, v_1)$ for some $\lambda, \mu\in
\mathbb{F}_{q^m}$. Looking at the leading coefficients, we deduce that $\mu =
\alpha_0$ and $\lambda=\alpha_1$. Now, writing the conditions such that $w_0\bar
h_0+w_1\bar h_1\equiv 0 \mod Q$, we obtain a linear system of two equations in
$4$ unknowns $\alpha_0, \alpha_1, \beta_0, \beta_1$. We solve the system by
expressing the $\beta_i$'s as a linear combination of the $\alpha_i$'s:
\[
  \begin{cases}
    \beta_0 = f_{0,0}(d, d_0, d_1, e, e_0, e_1)\alpha_0 + f_{0,1}(d, d_0, d_1, e,
    e_0, e_1)\alpha_1 \\
    \beta_1 = f_{1,0}(d, d_0, d_1, e, e_0, e_1)\alpha_0 + f_{1,1}(d, d_0, d_1, e,
    e_0, e_1)\alpha_1 
  \end{cases}
\]
where the expressions $f_{i, j}(d, d_0, d_1, e, e_0, e_1)$ depend only on the
known constants $d, d_0, d_1, e, e_0, e_1$ and appear while solving the system. But we also have $\beta_0 = \mu v_0
+ \lambda u_0$, and recall that $\mu = \alpha_0$ and $\lambda = \alpha_1$, it
follows that $\beta_0 = v_0\alpha_0+u_0\alpha_1$. By identification, we obtain
that $v_0 = f_{0,0}(d, d_0, d_1, e, e_0, e_1)$ and $u_0 = f_{0,1}(d, d_0, d_1,
e, e_0, e_1)\alpha_1$. The same discussion allows us to find $u_1$ and $v_1$.
Since we have
\[
  h_1(X^{q+1}+aX^q+bX+c)\equiv(X+a)h_0+(bX+c)h_1\mod P,
\]
if $Q$ divides $(X+a)h_0+(bX+c)h_1$, a polynomial of degree at most $3$, then we
have that $(X+a)h_0+(bX+c)h_1=Q\times R$, where $R$ is a linear polynomial. If
on top of that, the polynomial $X^{q+1}+aX^q+bX+c$ splits completely over
$\mathbb{F}_{q^m}$, then we have a relation between $Q$, polynomials of degree
$1$, and $h_1$ (which logarithm is supposed to be known). The goal is thus to
find a triple $(a, b, c)$ satisfying the two conditions. To do that, we choose
$B\in \mathcal B$ and we remark that $(X+a,
bX+c)\in L_Q$ implies that $(X+a, bX+c)=b(u_0, X+u_1)+(X+v_0, v_1)$. Hence, we
have $a=bu_0+v_0$ and $c=bu_1+v_1$. Rewriting $a$ and $c$ in the conditions
on $(a,b,c)$: $c\neq ab,b\neq a^q$ and $\frac{(b-a^q)^{q+1}}{(c-ab)^q}=B$, we
get the condition
\[
  B = \frac{(-u_0^qb^q+b-v_0^q)^{q+1}}{(-u_0b^2+(u_1-v_0)b+v_1)^q}
\]
and we can find a suitable $b$ in polynomial time in $q$ and $m$ by finding a
root to the degree
$q^2+q$ polynomial
\[
  D = (-u_0^qX^q+X-v_0^q)^{q+1} - B(-u_0X^2+(u_1-v_0)X+v_1)^q.
\]
Expanding the polynomial, we can see that it is quite sparse, indeed the only
non-zero coefficients are those of degree $q^2+q, q^2+1, q^2, 2q, q+1, q, 1$ and
the constant:
\begin{eqnarray*}
  D &=&
  u_0^{q^2+q}X^{q^2+q}-u_0^{q^2}X^{q^2+1}+u_0^{q^2}v_0^qX^{q^2}+(Bu_0^q-u_0^q)X^{2q}+X^{q+1} \\
  & & +(v_0^{q^2}u_0^q-v_0^q+B(v_0^q-u_1^q))X^q-v_0^{q^2}X+v_0^{q^2+q}-Bv_1^q.
\end{eqnarray*}
Alternatively, we can write $b$ in a $\mathbb{F}_{q^m}/\mathbb{F}_q$
basis and solve a quadratic system in $m$ variables with Gröbner bases
algorithms, with an exponential time in $m$. In practice~\cite{Adj16}, the
second option is used, because this on-the-fly elimination is used with small $m$.

We also emphasize on the fact that this elimination works if a suitable element
$b$ is found. For each $B\in\mathcal B$, the probability of finding a suitable
$b$ is about $\frac{1}{2}$, so if
$m\geq4$, then $|\mathcal B|\approx q$ and the probability than the
elimination works is overwhelming.

\subsection{The descent}

Let now $Q\in\mathbb{F}_{q}[X]$ be an irreducible polynomial over $\mathbb{F}_{q}$ of degree
$2m$, with $m\geq4$. We have
\[
  Q = \prod_{i=0}^{m-1}Q_{i}
\]
where the polynomials $Q_i\in\mathbb{F}_{q^m}[X]$ are irreducible
polynomials over $\mathbb{F}_{q^m}$ of degree $2$, and are all
conjugates. By conjugates, we mean that for all $0\leq i\leq m-1$,
$Q_i=Q_0^{[i]}$, where $Q_0^{[i]}$ denotes the polynomial $Q_0$ with all
coefficients raised to the power $q^i$. By applying the on-the-fly
elimination to $Q_0$, wo obtain 
\[
  R_0Q_0=\prod_{j=1}^{q+1}R_j
\]
where, for all $0\leq j\leq q+1$, $R_j\in\mathbb{F}_{q^m}[X]$ is a linear
polynomial over $\mathbb{F}_{q^m}$. We also deduce that
\[
  R_{0}^{[i]}Q_i=\prod_{j=1}^{q+1}R_j^{[i]}
\]
and it follows that
\[
  (\prod_{i=0}^{m-1}R_{0}^{[i]})\times Q =
  \prod_{j=1}^{q+1}(\prod_{i=0}^{m-1}R_j^{[i]}).
\]
Now recall that $N_j:=\prod_{i=0}^{m-1}R_{j}^{[i]}$ is the norm of the
polynomial $R_j$, and that the norm of a linear polynomial over
$\mathbb{F}_{q^m}/\mathbb{F}_q$ is an irreducible polynomial over
$\mathbb{F}_q$ of degree
$e$, raised to the power $f$, such that $ef=m$. Hence, we have
$N_j=T_j^{f_j}$, with $T_j\in\mathbb{F}_{q}[X]$, $\deg T_j = e_j$, and
$e_jf_j=m$. In the end, we have expressed the polynomial $Q$ as a product of
polynomials with degree dividing $m$.

To be able to really perform this descent, we must have a polynomial $Q$ with a 
power of $2$ degree, this is possible thanks to Theorem $5.1$ proved 
in~\cite{Wan97} by Wan that roughly states that we can represent any element in
$\mathcal G$ by a polynomial with a power of $2$ degree. Performing the
descent, a tree is built in which the logarithm of a node is expressed
as a linear combination of its children. The total complexity of the algorithm
is then the number of nodes of this tree. We have seen that the arity of the
tree is $q+2$, and the height of the tree is $O(\log n)$, the number of nodes
is then $(q+2)^{\log n}$. Since we are in the small characteristic case, we
can write this complexity $l^{O(\log l)}$, where $l=\log(q^n)$ is the bitsize of
$\mathcal G$, and we see that the algorithm is quasi-polynomial.
\section{A few comments}

\begin{itemize}
  \item In practical works, summarised in Gora Adj PhD thesis~\cite{Adj16}, we
    can see that this algorithm in not really used all the way from elements
    of high degree (\ie $\geq 200$ in~\cite{Adj16}) to elements in the factor base. Instead, other descents
    with smaller arity are first used to reduce the degree of the elements
    until having elements of small degree (\ie $16$ in~\cite{Adj16}).
  \item There are technicalities hidden in this document, they are discussed
    in~\cite{GKZ14}. For example there are ``traps'' that we must avoid: it is
    impossible to eliminate a polynomial $Q\neq P$ that divides
    $h_1X^q-h_0$, where $P$ is again the defining polynomial of
    $\mathbb{F}_{q^n}$. The reason behind that is that we act as if our
    computations were living in $\mathbb{F}_{q^m}$, but they are in fact living
    in $\mathbb{F}_{q}[X]/(h_1X^q-h_0)$.
\end{itemize}

\clearpage
\bibliographystyle{plain}
\bibliography{dlog}
\end{document}
